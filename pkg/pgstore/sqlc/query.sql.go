// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.17.2
// source: query.sql

package sqlc

import (
	"context"
	"encoding/json"

	"github.com/google/uuid"
)

const appendEvent = `-- name: AppendEvent :one
INSERT INTO event_store.event (
  transaction_id,
  aggregate_id,
  data,
  version
) VALUES (
  pg_current_xact_id(),
  $1,
  $2,
  $3
)
RETURNING id, transaction_id, aggregate_id, version, data
`

type AppendEventParams struct {
	AggregateID uuid.UUID
	Data        json.RawMessage
	Version     int32
}

func (q *Queries) AppendEvent(ctx context.Context, arg AppendEventParams) (EventStoreEvent, error) {
	row := q.db.QueryRowContext(ctx, appendEvent, arg.AggregateID, arg.Data, arg.Version)
	var i EventStoreEvent
	err := row.Scan(
		&i.ID,
		&i.TransactionID,
		&i.AggregateID,
		&i.Version,
		&i.Data,
	)
	return i, err
}

const createAggregate = `-- name: CreateAggregate :exec
INSERT INTO event_store.aggregate (
  id,
  version,
  aggregate_type
) VALUES (
  $1,
  0,
  $2
)
ON CONFLICT DO NOTHING
`

type CreateAggregateParams struct {
	AggregateID   uuid.UUID
	AggregateType string
}

func (q *Queries) CreateAggregate(ctx context.Context, arg CreateAggregateParams) error {
	_, err := q.db.ExecContext(ctx, createAggregate, arg.AggregateID, arg.AggregateType)
	return err
}

const createAggregateSnapshot = `-- name: CreateAggregateSnapshot :execrows
INSERT INTO event_store.aggregate_snapshot (
  aggregate_id,
  version,
  data
) VALUES (
  $1,
  $2,
  $3
)
ON CONFLICT DO NOTHING
`

type CreateAggregateSnapshotParams struct {
	AggregateID uuid.UUID
	Version     int32
	Data        json.RawMessage
}

func (q *Queries) CreateAggregateSnapshot(ctx context.Context, arg CreateAggregateSnapshotParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, createAggregateSnapshot, arg.AggregateID, arg.Version, arg.Data)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const loadAggregateSnapshot = `-- name: LoadAggregateSnapshot :one
SELECT a.aggregate_type, s.data
FROM event_store.aggregate_snapshot s
  JOIN event_store.aggregate a
  ON a.id = s.aggregate_id
WHERE s.aggregate_id = $1
  AND s.VERSION <= $2
ORDER BY s.version DESC
LIMIT 1
`

type LoadAggregateSnapshotParams struct {
	AggregateID uuid.UUID
	Version     int32
}

type LoadAggregateSnapshotRow struct {
	AggregateType string
	Data          json.RawMessage
}

func (q *Queries) LoadAggregateSnapshot(ctx context.Context, arg LoadAggregateSnapshotParams) (LoadAggregateSnapshotRow, error) {
	row := q.db.QueryRowContext(ctx, loadAggregateSnapshot, arg.AggregateID, arg.Version)
	var i LoadAggregateSnapshotRow
	err := row.Scan(&i.AggregateType, &i.Data)
	return i, err
}

const loadStream = `-- name: LoadStream :many
SELECT data, version
FROM event_store.event
WHERE aggregate_id = $1
  AND version >= $2
  AND version <= $3
ORDER BY version ASC
`

type LoadStreamParams struct {
	AggregateID uuid.UUID
	FromVersion int32
	ToVersion   int32
}

type LoadStreamRow struct {
	Data    json.RawMessage
	Version int32
}

func (q *Queries) LoadStream(ctx context.Context, arg LoadStreamParams) ([]LoadStreamRow, error) {
	rows, err := q.db.QueryContext(ctx, loadStream, arg.AggregateID, arg.FromVersion, arg.ToVersion)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []LoadStreamRow
	for rows.Next() {
		var i LoadStreamRow
		if err := rows.Scan(&i.Data, &i.Version); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateAggregate = `-- name: UpdateAggregate :execrows
UPDATE event_store.aggregate
SET version = $1
WHERE id = $2
  AND version = $3
`

type UpdateAggregateParams struct {
	NewVersion      int32
	AggregateID     uuid.UUID
	ExpectedVersion int32
}

func (q *Queries) UpdateAggregate(ctx context.Context, arg UpdateAggregateParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, updateAggregate, arg.NewVersion, arg.AggregateID, arg.ExpectedVersion)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}
